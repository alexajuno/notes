# Software Engineering - A Practicioner Approach

## Chapter 1: Software and Software Engineering

- A conversation about cloud computing is the new generation of software
- A short introduction to software and software engineering

### 1.1 The Nature of Software

#### 1.1.1 Defining Software

- Software is developed or engined
- Software doesn't wear out
- Industry is moving toward component-based construction, most software continues to be custom built

#### 1.1.2 Software Application Domains

- Many domains that I don't read

#### 1.1.3 Legacy Software

- Just don't do anything until significant changes are required. More in chapter 29

### 1.2 The Unique Nature of WebApps

- So many aspects of webapps that I don't remember

### 1.3 Software Engineering

- software requirements
  - Understand the problem before develope a software solution
  - Design is required for sophisticated software
  - Software need to be high quality because people depend on it
  - Maintainability
  => Software engineering
- Software engineering: layered technology
  - quality focus: bedrock
  - process: foundation
  - methods
  - tools

### 1.4 The Software Process

- Providing a high level approach to all project's sizes and allow people to choose the actions and tasks to fit that process framework
- Encompass five activites
  - Communication
  - Planning
  - Modeling
  - Construction
  - Deployment
- Umbrella activities?
- Overall the process application is very flexible but I'm too lazy to read and memorize

### 1.5 Software Engineering Practice

#### 1.5.1 The Essence of Practice

- Sequential steps in software engineering practice

#### 1.5.2 General Principles

- Some nice principles but I won't memorize them

### 1.6 Software Myths

- Management's Myth
- Customer's myth
- practicioner's myth

## Part 1: The Software Process

### Chapter 2: Process Models

#### 2.1 A Generic Process Model

- framework activity -> actions -> tasks
- five framework activities: communication, planning, modeling, construction, deployment
- types of process flow: linear, iterative, evolutionary, parallel

##### 2.1.1 Defining a framework activity

- For different levels of projects, you will need different actions within a framework activity

##### 2.1.2 Identifying a task set

- word: elicitation = requirements gathering

##### 2.1.3 Process Patterns

- It's like a playbook in cybersecurity
- I would like to write some for myself and teams that I'll manage in the future

#### 2.2 Process Assessment and Improvement

- Some standards for software assessment

#### 2.3 Prescriptive Process Models

- These models have good intention but still don't work effectively
- Some prescriptive process models:

##### 2.3.1 Waterfall

- A variation: V-model
- In reality, the activities are not sequential and linear

##### 2.3.2 Incremental Process Models

- = linear + parallel process flow
- Each increment is a working software, suitable for a project that doesn't have a defined deadline and resources

##### 2.3.3 Evolutionary Process Models

- Prototyping approach: build a prototype of the system to test the feasibility and then develop it fully
  - Some problems with this approach:
    - People might have misunderstandings about the real product with the prototype
- Spiral model: it seems like the prototype with multiple cycles
  - This model focuses on risk management
  - I haven't understood this but this model requires an risk assessment expertise to convince the customer that this spiral approach is controllable
  - Oh, via an example, I understand it now. Because we will change the requirements each time, it's really hard to control the unexpected things might happen

##### 2.3.4 Concurrent models

- This model only cares about the state of a project, not the activities.

##### 2.3.5 A Final Word on Evolutionary Process Models

- These models are suitable for a rapid changing requirements in software engineering
- But project management and estimation techniques require a linear model
- In the end, we need to find balance between these two: change management and arbiter

#### 2.4 Specialized Process Models

##### 2.4.1 Component-Based Development

- Suitable for premade components of a system to be used in a project

##### 2.4.2 The Formal Methods Model

- Using rigorous mathematical notations
- Pros: defect-free software
- Cons: time-consuming

##### 2.4.3 Aspect-Oriented Software Development

- I guess I've read about this new programming paradigm somewhere, in which we focus on the crosscutting concerns instead of the business logic with modules.

#### 2.5 The Unified Process

##### 2.5.1 History

##### 2.5.2 Phases

- From discussed five activities converting to phases: inception -> elaboration -> construction -> transition -> production. But I haven't understood what is the reason for this, maybe just another name

#### 2.6 Personal and Team Process Models

##### 2.6.1 Personal Software Process

- Defines five framework activities
- Noted from the author: this model hasn't been widely adopted

##### 2.6.2 Team Software Process

- Similar to personal software process but for teams

#### 2.7 Process Technology

- Some tools presented but I'm not sure if I'll use them

#### 2.8 Product and Process

- For this part, the conclusion is we should both creating high-level design and build prototypes to stay in the state between both product and process. We shouldn't focus on a single side.

#### 2.9 Summary

### Chapter 3: Agile Development


